# Actors
The basic characteristic of actors is that they model the world as stateful entities communicating with each other by
explicit message passing.
As computational entities, actors have these characteristics:

- They communicate with asynchronous messaging instead of method calls
- They manage their own state
- When responding to a message, they can:
    - Create other (child) actors
    - Send messages to other actors
    - Stop (child) actors or themselves
    
## Issues

### The illusion of encapsulation
- Objects can only guarantee encapsulation (protection of invariants) in the face of single-threaded access, multi-thread execution almost always leads to corrupted internal state. Every invariant can be violated by having two contending threads in the same code segment.
- While locks seem to be the natural remedy to uphold encapsulation with multiple threads, in practice they are inefficient and easily lead to deadlocks in any application of real-world scale.
- Locks work locally, attempts to make them distributed exist, but offer limited potential for scaling out.

### The illusion of shared memory on modern computer architectures
- There is no real shared memory anymore, CPU cores pass chunks of data (cache lines) explicitly to each other just as computers on a network do. Inter-CPU communication and network communication have more in common than many realize. Passing messages is the norm now be it across CPUs or networked computers.
- Instead of hiding the message passing aspect through variables marked as shared or using atomic data structures, a more disciplined and principled approach is to keep state local to a concurrent entity and propagate data or events between concurrent entities explicitly via messages.

### The illusion of a call stack
- To achieve any meaningful concurrency and performance on current systems, threads must delegate tasks among each other in an efficient way without blocking. With this style of task-delegating concurrency (and even more so with networked/distributed computing) call stack-based error handling breaks down and new, explicit error signaling mechanisms need to be introduced. Failures become part of the domain model.
- Concurrent systems with work delegation needs to handle service faults and have principled means to recover from them. Clients of such services need to be aware that tasks/messages might get lost during restarts. Even if loss does not happen, a response might be delayed arbitrarily due to previously enqueued tasks (a long queue), delays caused by garbage collection, etc. In face of these, concurrent systems should handle response deadlines in the form of timeouts, just like networked/distributed systems.

## Solution

### Usage of message passing avoids locking and blocking
This is what happens when an actor receives a message:
- The actor adds the message to the end of a queue.
- If the actor was not scheduled for execution, it is marked as ready to execute.
- A (hidden) scheduler entity takes the actor and starts executing it.
- Actor picks the message from the front of the queue.
- Actor modifies internal state, sends messages to other actors.
- The actor is unscheduled.

To accomplish this behavior, actors have: 
- A Mailbox (the queue where messages end up).
- A Behavior (the state of the actor, internal variables etc.).
- Messages (pieces of data representing a signal, similar to method calls and their parameters).
- An Execution Environment (the machinery that takes actors that have messages to react to and invokes their message handling code).
- An Address (more on this later).

### Actors handle error situations gracefully
- The first case is when the delegated task on the target actor failed due to an error in the task in
this case the target actor can message back with some error response
- The second case is when a service itself encounters an internal fault, in this case parent is notified
that a child actor has failed so it can handle it gracefully. If parent fails then all of its child actors
are stopped recursively

Parent can restart or stop its children. Children does not go dead silently either they fail and 
parent is notified or they are stopped and intrested parties are notified

## Libraries
- **Actors**: provides actor api
- **Remoting**: enable remote actors to exchange messages
- **Cluster**: instead of remoting what you noramlly use is cluster which provide high level api to manage actor clusters
- **Sharding**: Helps distribute set of actors among akka cluster
- **Cluster Singleton**: For having a single entity responsible for a given task which is shared among other members of the 
cluster and migrated if the host system fails
- **Cluster Publish-Subscribe**: Broadcast messages and manages subscription in a cluster
- **Persistence**: Actors have volatile state and if they crash their state can be regenerated by replaying events
which led them to current state, persistence provide api to persist those events
- **Distributed Data**: Provides api for creating eventual consistent data structures which accepts concurrent reads
on different nodes and then merges the change in future to resolve conflicts (uses CRDTs)
- **Streams**: provides streams api for handling large amount of data
- **HTTP**: provides http api

